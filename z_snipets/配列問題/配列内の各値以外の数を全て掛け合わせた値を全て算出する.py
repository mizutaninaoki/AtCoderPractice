# see: https://leetcode.com/problems/product-of-array-except-self/description/
# ith以外の要素の積は、その要素の左側と右側の要素の積に等しくなります。
# したがって、アイデアは、入力に対して 2 つのパスを実行しnums、補助リストを使用してres中間結果を保存することです。
# 最初のパスは最初から最後まで実行し、反復ごとに累積積を対応するインデックスに格納します。
# これにより、番目のインデックスres の の値は0 から までのすべての要素の積に等しくなります。
# の最後から最初まで行う 2 番目のパス。再び満たされた要素の積を蓄積し、インデックスの値がresinumsi-1res[i] = product(nums[0:i-1])numsresiは、
# このインデックスの値とパスからの累積値の積に等しくなります。最後に、res必要な答えです。
# 他者の解答(左からの累積値、右からの累積値を利用する解法)
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = []

        # 左側からスタートして、現在のインデックスまでの累積値をresに入れていく。
        # (ith以外の要素の積は、その要素の左側と右側の要素の積に等しくなり、この左側の要素の積に使うため。)
        acc = 1
        for n in nums:  # numsの左側からスタート
            res.append(acc)
            acc *= n

        # 右側からスタートして、現在のインデックスまでの累積値を右側の各インデックスまでの累積値と掛けて、resに入れていく。
        # (ith以外の要素の積は、その要素の左側と右側の要素の積に等しくなり、このすでに算出した左側の要素と今回の右側の累積値を掛けると、そのインデックスの値以外を全て掛けた値になるため。)
        acc = 1
        for i in reversed(range(len(nums))):  # numsの右側からスタート
            res[i] *= acc
            acc *= nums[i]

        # resには各インデックスに対応した、そのインデックスの値以外を全て掛けた値が格納されている。
        return res
