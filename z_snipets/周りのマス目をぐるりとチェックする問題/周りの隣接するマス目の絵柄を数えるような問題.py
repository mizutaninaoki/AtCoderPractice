###########################################################################################
# 周りの隣接するマス目の絵柄を数えるような問題
###########################################################################################
# 鹿本と違い、DX->横方向、DY->縦方向 を表すようにしているため、zip(DX, DY)のループ内の「nj, ni = j + dx, i + dy」の書き方が逆になっている
# (鹿本P.135参照)

# ---------------------------
# 現在地を含めない場合
# ---------------------------
# # 0:下、1:右、2:上、3:左、 4:右下、5：右上、6:左上、7:左下
# DX = [0, 1, 0, -1, 1, 1, -1, -1]
# DY = [1, 0, -1, 0, 1, -1, -1, 1]

# ---------------------------
# 現在地を含める場合
# ---------------------------
# 0:下、1:右、2:上、3:左、 4:右下、5：右上、6:左上、7:左下、8:現在地
DX = [0, 1, 0, -1, 1, 1, -1, -1, 0]
DY = [1, 0, -1, 0, 1, -1, -1, 1, 0]

n, m = map(int, input().split())

L = [input() for _ in range(n)]
# 全て0で構成されたLと同じ構造の二重配列(Lの中の配列には文字列を入れているから、厳密には違うけど。。。)
result = [[0]*m for _ in range(n)]

for i in range(n):
    for j in range(m):
        for dx, dy in zip(DX, DY):
            nj, ni = j + dx, i + dy
            # チェック対象の隣接するマス目が、盤面外に出ていないかチェック
            # 横のマス目の数(nj)がn以上になっていたら、盤面外。縦のマス目の数(ni)がn以上になっていたら、盤面外。
            if ni < 0 or ni >= n or nj < 0 or nj >= m:
                continue

            if L[ni][nj] == "#":
                result[i][j] += 1

for k in result:
    print(*k, sep="")
