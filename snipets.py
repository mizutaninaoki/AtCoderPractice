###########################################################################################
# 周りの隣接するマス目の絵柄を数えるような問題
###########################################################################################
# 鹿本と違い、DX->横方向、DY->縦方向 を表すようにしているため、zip(DX, DY)のループ内の「nj, ni = j + dx, i + dy」の書き方が逆になっている
# (鹿本P.135参照)

# ---------------------------
# 現在地を含めない場合
# ---------------------------
# # 0:下、1:右、2:上、3:左、 4:右下、5：右上、6:左上、7:左下
# DX = [0, 1, 0, -1, 1, 1, -1, -1]
# DY = [1, 0, -1, 0, 1, -1, -1, 1]

# ---------------------------
# 現在地を含める場合
# ---------------------------
# 0:下、1:右、2:上、3:左、 4:右下、5：右上、6:左上、7:左下、8:現在地
DX = [0, 1, 0, -1, 1, 1, -1, -1, 0]
DY = [1, 0, -1, 0, 1, -1, -1, 1, 0]

n, m = map(int, input().split())

L = [input() for _ in range(n)]
# 全て0で構成されたLと同じ構造の二重配列(Lの中の配列には文字列を入れているから、厳密には違うけど。。。)
result = [[0]*m for _ in range(n)]

for i in range(n):
    for j in range(m):
        for dx, dy in zip(DX, DY):
            nj, ni = j + dx, i + dy
            # チェック対象の隣接するマス目が、盤面外に出ていないかチェック
            # 横のマス目の数(nj)がn以上になっていたら、盤面外。縦のマス目の数(ni)がn以上になっていたら、盤面外。
            if ni < 0 or ni >= n or nj < 0 or nj >= m:
                continue

            if L[ni][nj] == "#":
                result[i][j] += 1

for k in result:
    print(*k, sep="")


###########################################################################################
# １つのマス目から条件によって、他の全てのマス目に変更するかどうか比較する場合(abc295のb問題)
###########################################################################################
R, C = map(int, input().split())
B = [list(input()) for _ in range(R)]

for i in range(R):
    for j in range(C):
        x = B[i][j]
        # それぞれのマスまでループして、そこからまた全体的にループで周り、マンハッタン距離の範囲内かどうか調べて、該当すればピリオドに変更する
        for k in range(R):
            for l in range(C):
                # マス目の文字が数字の時のみint型に変換して、マンハッタン距離と比較
                d = int(B[k][l]) if B[k][l].isdigit() else -1
                if abs(i-k) + abs(j-l) <= d:
                    x = "."
        print(x, end="")
    print()
